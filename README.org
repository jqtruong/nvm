#+STARTUP: hidestars
#+TODO: TODO IN_PROGRESS | DONE

* Summary
  In honor of my grandfather whose mind was so emcompassing
  that it left its shell long before his body realized.

* WebGL

** [2019-04-26 Fri]
   geez... a year later. learning from [[file:/opt/jqtruong/programmingtil-webgl][ProgrammingTIL -
   WebGL]]. really great set of  tutorials, so far.

   in tutorial 26, color gets interpolated from one point to
   another; it's kinda cool.

   in tutorial 27, i'm drawing a circle with a variant
   number of sides, and it's interesting how an inner circle
   is drawn. it draws using =TRIANGLE_STRIP=, which acts
   like a =LINE_STRIP=, ie. the last node connects to the
   the previous node, but the previous two nodes for a
   triangle. (see tutorial 25 to play with the different
   draw styles.) #27 loops through 360° and draws super thin
   triangles. 

** [2018-04-13 Fri]
   wow, i have been working little by little but i really
   suck at updating this log.

   anyway, now i understand orthographic projection a bit
   more; i need to rotate it around the x-axis a bit to make
   everything look 3d. so now i can start adding those
   windows!

** [2018-02-09 Fri]
   based on this [[https://computergraphics.stackexchange.com/questions/1608/how-to-combine-rotation-in-2-axis-into-one-matrix][answer]], i can rotate on multiple axis by
   multiplying the transformed matrices together:
   : RotXMat * RotYMat * RotZMat

** [2018-02-04 Sun]
   trying to get ortho to show. i think that's what i need:
   3d on a 2d plane and space.

   finally got it to work!
   1. doesn't seem to matter what z-scale is as long as it's
      between -1 and 1, but maybe it's needed for objects in
      front and behind other objects.
   2. vertices aren't normalized, since they are done in the
      projection.

** [2018-01-25 Thu]
   .o0(i really need to remember to write my journey through
   this project down each day...)

   i got to a point where i can draw a rectangle but not
   without problems. i'm only sending 2 components, x and y,
   in the buffer, just like in the demo but somehow the
   latter works with a =vec4= position attribute but not
   mine; i have to make it a =vec2= and fill it up to a
   =vec4=. So far, this is a mystery but i need to move on,
   and history tells me that i will figure it out someday.

   i need to move =gl= functions into its own
   library. keeping the context in =Canvas= is more
   typing... 

   then add a rotation to the rectangle.

** [2017-12-27 Wed]
   i got the canvas almost set up. programs go in there
   rather fitly, but wondering about buffers and/or
   variables. in nullprogram's sample code, the variables
   are attached at render, and, in learningwebgl, they are
   attached during program inititialization and in render.

** [2017-12-25 Mon]
   looks like there will be many programs for each thing i
   want to draw. 
   
   WebGL pipeline (high-level):
   1. Runs the vertex shader on all of the vertices to work
      out where everything is.
   2. Linearly interpolates between the vertices, which
      tells it which fragments (which for the moment you can
      treat as being the same as pixels) need to be painted.
   3. For each fragment, run the fragment shader on it to
      work out its colour.
   4. Write it to the frame buffer.

*** Variable types
    - [[https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#attributes][attributes]] :: data pulled from buffers
    - [[https://webglfundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#uniforms][uniforms]] :: values that stay the same for all vertices
         of a single draw call

** Topics

*** [[https://webglfundamentals.org/webgl/lessons/webgl-drawing-multiple-things.html][Drawing multiple things]]
    For each thing you want to draw
    - call =gl.useProgram= for the program needed to draw.
    - setup attributes for the thing you want to draw
    - for each attribute call:
      - =gl.bindBuffer=
      - =gl.vertexAttribPointer=
      - =gl.enableVertexAttribArray=
    - setup uniforms for the thing you want to draw
    - call =gl.uniformXXX= for each uniform
    - call =gl.activeTexture= and =gl.bindTexture= to assign
      textures to texture units.
    - call =gl.drawArrays= or =gl.drawElements=

*** Orthographic projection matrix

*** Perspective projection matrix
    - fov :: 45° field of view
    - f :: inverse tangent of 22.5°

* Matrix

** Multiply
   | 0 | 1 | 2 |   | a |   | (0*a) + (1*b) + (2*c) |
   | 3 | 4 | 5 | x | b | = | (3*a) + (4*b) + (5*c) |
   | 6 | 7 | 8 |   | c |   | (6*a) + (7*b) + (8*c) |

*** Dimension rule
    3x3 ⋅ 3x1 = 3x1
    AxB ⋅ CxD = AxD as long as B == C
   
* Refs
  - http://nullprogram.com/sphere-js/
  - [[http://learningwebgl.com/blog/?p=859][learningwebgl: blending]]
  - [[https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix][ortho projection explaination]]

** Webserver
   Start a webserver to serve the shader files, just for
   better legibility.

*** Lisp way
    #+BEGIN_SRC lisp
      (ql:quickload :hunchentoot)
      (hunchentoot:start (make-instance 'hunchentoot:easy-acceptor :port 4242))
      (push (hunchentoot:create-folder-dispatcher-and-handler
             "/nvm/" "~/work/gamedev/passed-in-future/nvm/")
            hunchentoot:*dispatch-table*)
    #+END_SRC
    
    then visit http://localhost:4242/nvm/index.html.

*** Node way
    =http-server= boom!

* Tasks

** IN_PROGRESS learn some WebGL
   Start with rotating colorful rectangles.

** TODO draw multiple things
